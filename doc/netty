IO基础
linux网络io模型
linux内核将所有外部设备看作一个文件夹操作,对一个文件的读写会调用内核的系统命令,返回一个file descriptor(fd,文件描述符).对一个socket的
读写也会有相应的描述符,称为socketfd,描述符是一个数字,指向内核中的一个结构体
IO模型
1.阻塞IO模型
缺省情形下,所有文件操作都是阻塞的.
2.非阻塞IO模型
从应用层到内核的俄时候,如果该缓冲区没有数据的时候,直接返回错误,存在一个线程轮询缓冲区状态
3.IO复用模型
linux提供select/poll,进程通过将一个或多个fd传递给select或poll系统调用,阻塞在select操作上.这样select/poll可以监听多个fd是否处于
就绪状态.select/poll是顺序扫描fd检查是否就绪,支持的fd数量有限.
linux另外提供epoll,基于时间驱动调用rollback

select和epoll
执行select时顺序扫描注册的fd是否就绪
epoll使用基于事件驱动的方式替代顺序扫描,因此性能更高
1.epoll支持一个进程打开的soket描述符不受限制
2.IO效率不会因为fd数目的增加而线性下降
因为select是轮询所有注册的fd的状态,而epoll是在fd就绪后的回调
3.使用mmap加速内核和用户空间的消息传递
4.epoll的api更简单

4.信号驱动IO模型
首先开启套接口信号驱动IO功能,并通过系统调用sigaction执行一个信号处理函数.当数据准备就绪时,就为该进程生成一个SIGIO信号,通过信号回调通知
应用程序读取数据
5.异步IO
告知内核启动某个操作,并让内核在整个操作完成后通知.与信号驱动的区别:
信号驱动通知何时开始,异步io通知何时完成

java核心类库多路复用器selector基于epoll

IO多路复用技术:
在IO编程过程中,当需要同时处理多个客户端接入时.可以利用多线程或者IO多路复用技术进行处理.IO多路复用技术通过把多个IO的阻塞复用到同一个
select的阻塞上,从而使得系统在单线程的情况下可以同时处理多个客户端的请求.

java的IO演进
jdk1.4前,基于socket通信都采用了同步阻塞模式
nio提供:
1.进行异步io操作的缓冲区ByteBuffer等
2.进行异步IO操作的管道pipe
3.进行IO操作的channel.
4.多种字符集的编码能力和解码能力
5.实现非阻塞IO操作的多路复用selector
6.正则表达式类库
7.文件通道FileChannel
nio2.0 提供:
1.提供批量获取文件属性的api
2.提供aio功能
3.定义通道功能
