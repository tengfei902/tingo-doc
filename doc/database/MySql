MySQL

存储引擎
InnoDB
MyISAM
Archive 只支持insert和select操作,会缓存所有的写并利用zlib对插入的行进行压缩,所以比MyISAM表的磁盘IO低,但是每次select操作都需要全表扫描,
在一个查询开始直到返回表中存在的所有行数前,archive引擎会阻止其他select执行.
Blackhole:会丢弃所有插入,可用作复制数据到备库.
CSV:
Federated:
Memory:
所有数据保存在内存,不需要磁盘IO,Memory表支持哈希索引,因此查找速度很快
Merge:
多个MyISAM表合并成的虚拟表
NDB集群引擎:

基准测试:
检验给定的工作负载下会发生什么.可以观察系统不同压力下的行为,评估系统的容量,掌握哪些是重要的变化.
1.验证基于系统的一些假设,确认这些假设是否符合实际情况.
2.重现系统中的异常
3.测试系统当前的运行情况
4.模拟比当前系统更高的负载,找出可能遇到的性能瓶颈
5.规划未来的业务增长
6.测试应用适应可变环境的能力
7.测试不同硬件,操作系统的配置
8.测试新采购的设备是否配置正确

基准测试策略
1.针对整个系统的整体测试 full-stack
2.单独测试 single-component

测试指标:
1.吞吐量
单位时间内的事务处理数
2.响应时间或者延迟
测试任务所需的整体时间
3.并发性
4.可扩展性

schema与数据类型优化
1.选择优化的数据类型
更小通常更好,应尽量使用可以正确存储数据的最小数据类型
简单,简单数据类型通常需要更少的CPU周期
避免null,如果查询中包含可为null的列,更难优化,因为null的列使得索引,索引统计和值比较都更复杂.可为null的列会使用更多的存储空间,

MySQL schema设计中的陷阱
1.太多的列
存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据,然后在服务器层将缓冲内容解码成各个列,从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的.
2.太多的关联
3.全能的枚举 过度使用枚举,每个枚举值增加都需要执行alter table 操作
4.变相的枚举
5.非此发明的null

范式化与反范式化
在范式化的数据库中,每个数据只出现一次.在反范式化的数据中,信息是冗余的.

范式化的优点:
1.范式化的更新操作比反范式化要快
2.当数据较好的范式化时,就只有很少或者没有重复数据,所以只需要修改更少的数据
3.范式化的表通常更小,可以更好的放在内存里
4.很少有多余的数据意味着检索表数据时更少需要distinct 或者group by
缺点:
通常需要关联

反范式化的优点和缺点
可以避免关联

混用范式化和反范式化

mysql schema设计原则
1.避免过度设计
2.使用小而简单的合适数据类型,避免null
3.使用相同的数据类型存储相似或相关的值
4.注意可变长字符串
5.尽量使用整型定义标示列

索引
索引类型:
1.B-Tree索引
B-Tree索引可以加快访问数据的速度,因为存储引擎不再需要进行全表扫描来获取需要的数据,取而代之的时从索引的根节点开始进行搜索,根节点的槽中存放着指向子节点的指针,存储引擎根据这些指针向下层
查找.
B-Tree对索引列是顺序组织存储的,所以适合查找范围数据
适用范围:
1.全值匹配
2.匹配最左前缀
3.匹配列前缀
4.匹配范围值
5.精确匹配某一列并范围匹配另一列
6.只访问索引的查询
order by:
按索引建立顺序排序方式排序

限制:
1.如果不是按照索引最左列开始查找,则无法使用索引
2.不能跳过索引中的列
3.如果查询中某个列的范围查询,则其右边所有列都无法使用索引优化查找

哈希索引
哈希索引基于哈希表实现,只有精确匹配索引所有列的查询才有效.对于每一行数据,存储引擎都会对所有的索引列计算一个哈希码,哈希索引将哈西码存放在索引里,同时在h哈希表中保存指向每个数据行的指针.
限制:
1.索引只包含哈希值和指针,不包含索引字段值
2.不是按照顺序存储,无法用于排序
3.不支持部分匹配
4.只支持等值操作

自适应哈希索引
当innoDB注意到某些索引值使用频繁时,会在内存中基于B-Tree索引之上再建立一个哈希索引

空间数据索引R-Tree

全文索引
针对match against

其他索引类别


索引的优点:
1.索引减少了服务器需要扫描的数据量
2.索引可以使服务器避免排序和临时表
3.索引可以将随机IO转换为顺序IO

高性能索引策略
1.独立的列
索引列不能是表达式的一部分,也不能是函数的参数
2.前缀索引和索引选择性
2.多列索引

索引列的顺序
将选择性最高的列放在索引的最前.
性能并不只是依赖于所有列的选择性,也和查询条件的具体值有关,也就是值的分布有关.

聚簇索引
并不是一种单独的索引类型,而是一种数据存储方式.
当表有聚簇索引时,它的数据行实际上存放在索引的叶子页,叶子页保存了全部数据,但是节点页只保存索引列.
优点:
1.可以把相关的数据保存在一起
2.数据访问更快
3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值

覆盖索引:
如果一个索引包含所有需要查询的字段的值,称之为覆盖索引

使用索引扫描做排序
只有索引的列顺序和order by 子句顺序一致时,并且所有列的排序方向都一样,mysql才能使用索引做排序.如果查询需要关联表,则只有当order by子句引用的字段全部为第一个表时才能使用索引做排序.
有一种情况下,order by子句可以在不满足索引最左前缀的要求,就是前导列为常量.

压缩(前缀压缩)索引

冗余和重复索引
索引与锁

优化查询:
1.返回了不需要的列
2.扫描额外记录
衡量指标:响应时间,扫描的行数,返回的行数
访问类型:全表扫描,索引扫描,范围扫描,唯一索引扫描,常数引用



逻辑架构
客户端 -> 连接/线程处理 -> 查询缓存 -> 优化器 -> 存储引擎

连接管理与安全性:
优化与执行:
mysql解析查询,并创建内部数据结构解析树,然后对其进行各种优化,包括重写查询,决定表的读取顺序,以及选择合适的索引.
