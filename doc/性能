操作系统性能监控
1.CPU
系统态CPU使用率,使用率高说明共享资源有竞争或IO交互频繁
用户态CPU使用率
每时钟指令数IPC
每指令时钟周期CPI
2.内存
3.网络使用率
4.IO使用率
JVM
64bit vm内部普通对象指针的长度从32位变成64位,导致CPU高速缓存行中可用的oops变少,从而降低了CPU缓存的效率
VM类加载
1.类加载阶段
2.类加载器委派
当请求类加载器查找和加载某个类时,该加载器可以转而请求别的类加载器来加载,这被成为类加载器委派.
某个类的初始类加载器是对该类进行常量池符号解析的类加载器.
初始类加载器,定义类加载器
3.启动类加载器
类数据共享
4.类型安全
java的类型由类加载器和类的全限定名唯一确定
5.HotSpot类元数据
6.内部的类加载数据

字节码验证
对于版本号小于50的类文件(java6之前的jdk生成) vm使用类型推倒进行验证
大于或等于50的类文件,由于stackMapTable属性,会用类型检查进行验证


解释器
基于模板的解释器

异常处理
当与java的语义约束冲突时,java虚拟机会用异常通知程序.
抛出字节码;VM内部调用返回;JNI调用返回;java调用返回
如果当前方法中没有找到异常处理器,当前的活动栈帧就会选择退栈,重复这个过程知道找到异常处理器.

线程管理
线程模型
想成状态:
1.新线程
2.线程在java中
3.线程在VM中
4.线程阻塞
5.MONITOR_WAIT 线程正在等待监视锁
6.CONDVAR_WAIT 线程正在等待VM内部条件变量
7.OBJECT_WAIT 正在执行Object.wait

垃圾收集器
新生代
Eden:大多数新生对象分配在这里,大对象直接分配到老年代,minor GC后Eden几乎总是空的.
Survivor:一对.只有一块持有对象.
minor GC后,Eden中存活的对象被复制到未使用的survivor,被占用的不够老的对象也被复制到未使用的survivor.被使用的survivor里
足够老的对象被提升到老年代.
minor GC是复制垃圾收集器
minor GC中,survivor可能不足以容纳Eden和另一个Survivor中的存活对象.如果survivor中的存活对象溢出,对于的对象将被移到老年代.
如果老年代满了,会出发full GC

垃圾收集器
1.serial收集器
minor GC复制算法.
老年代华东压缩标记清除算法.
首先找出老年代中哪些依然存活的对象,然后将他们滑向堆的头部,从而将所有的空闲空间留在堆尾部的连续块中.使得将来任何在老年代中的分配
操作都可以使用快速的指针碰撞技术.

2.Parallel收集器
并行标记压缩算法,与serial相似,吞吐量优先

3.mostly-concurrent收集器 CMS算法
低延迟优先
并发标记清除收集器
开始一个短的停顿,称为初始标记,它标记那些可以从外部直接可达的老年代对象,然后在并发标记阶段,它标记所有从这些对象可达的存活对象.
因为在标记期间,应用可能正在运行并更新更新饮用,需要再次停顿,称为重新标记,重新遍历所有在并发标记期间有变化的对象并进行最后的标记.

CMS收集器引入并发预清除阶段.
缺点:
标记清除算法会导致空闲内存空间不连续,需要额外的的数据结构纪录哪些空间空闲.
需要更大的java堆,因为清除前没有执行内存回收.

缺乏压缩导致空间碎片化

G1收集器

JIT编译器

JVM性能监控
-XX:+ScanvengeBeforeFullGC ,fullGc前先执行MinorGC
-XX:+PrintGCDetals

visual VM

快速监控锁竞争

java应用性能分析

方法分析 java应用中方法执行时间信息
内存分析 java应用程序内存的使用信息,包括内存中已分配对象的数目,大小,活跃对象等信息

performance analyzer
CodeAnalyst performance Analyzer
VTune
NetBeans Profiler

性能优化机会:
1.系统内核态CPU使用
2.锁竞争            对同一个对象的操作,需持有同一个锁
3.volatile         低级别同步
4.调整数据结构大小   拆分数据结构,缩小锁粒度
5.增加并行性
6.过高的CPU使用率

concurrent atomic  java内存模型/java内存可见性
1. ++操作不是原子操作
2. 非原子操作有线程安全问题
3. 并发下的内存可见性
4. Atomic类通过CAS + volatile可以比synchronized做的更高效

sychronized,volatile,CAS


性能指标:吞吐量,延迟,内存占用
1.垃圾收集器调优
2.堆内存大小调整
计算活跃数据大小(full gc后java堆中老年代和永久代占用的空间大小)

-xmx,-xms 3~4倍full gc后老年代空间大小
-XX:PermSize 1.2~1.5倍full gc 后永久代空间占用量
-Xmn 1~1.5倍 full GC后老年代空间占用量
老年代:2~3倍Full GC后老年代空间占用量

CMS
压缩式GC
CMS调优因素
1.新生代对象提升速率较低
2.并行老年代回收线程回收速率
3.CMS回收器回收位于对象之间的空间造成的空间碎片化

Survivor
调整survivor空间时,如果新生代空间保持不变,会导致Eden空间减小,增加minor GC的频率

永久代垃圾收集

基准测试
1.预热阶段
