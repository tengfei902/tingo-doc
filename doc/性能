操作系统性能监控
1.CPU
系统态CPU使用率,使用率高说明共享资源有竞争或IO交互频繁
用户态CPU使用率
每时钟指令数IPC
每指令时钟周期CPI
2.内存
3.网络使用率
4.IO使用率
JVM
64bit vm内部普通对象指针的长度从32位变成64位,导致CPU高速缓存行中可用的oops变少,从而降低了CPU缓存的效率
VM类加载
1.类加载阶段
2.类加载器委派
当请求类加载器查找和加载某个类时,该加载器可以转而请求别的类加载器来加载,这被成为类加载器委派.
某个类的初始类加载器是对该类进行常量池符号解析的类加载器.
初始类加载器,定义类加载器
3.启动类加载器
类数据共享
4.类型安全
java的类型由类加载器和类的全限定名唯一确定
5.HotSpot类元数据
6.内部的类加载数据

字节码验证
对于版本号小于50的类文件(java6之前的jdk生成) vm使用类型推倒进行验证
大于或等于50的类文件,由于stackMapTable属性,会用类型检查进行验证


解释器
基于模板的解释器

异常处理
当与java的语义约束冲突时,java虚拟机会用异常通知程序.
抛出字节码;VM内部调用返回;JNI调用返回;java调用返回
如果当前方法中没有找到异常处理器,当前的活动栈帧就会选择退栈,重复这个过程知道找到异常处理器.

线程管理
线程模型
想成状态:
1.新线程
2.线程在java中
3.线程在VM中
4.线程阻塞
5.MONITOR_WAIT 线程正在等待监视锁
6.CONDVAR_WAIT 线程正在等待VM内部条件变量
7.OBJECT_WAIT 正在执行Object.wait

垃圾收集器
新生代
Eden:大多数新生对象分配在这里,大对象直接分配到老年代,minor GC后Eden几乎总是空的.
Survivor:一对.只有一块持有对象.
minor GC后,Eden中存活的对象被复制到未使用的survivor,被占用的不够老的对象也被复制到未使用的survivor.被使用的survivor里
足够老的对象被提升到老年代.
minor GC是复制垃圾收集器
minor GC中,survivor可能不足以容纳Eden和另一个Survivor中的存活对象.如果survivor中的存活对象溢出,对于的对象将被移到老年代.
如果老年代满了,会出发full GC

垃圾收集器
1.serial收集器
minor GC复制算法.
老年代华东压缩标记清除算法.
首先找出老年代中哪些依然存活的对象,然后将他们滑向堆的头部,从而将所有的空闲空间留在堆尾部的连续块中.使得将来任何在老年代中的分配
操作都可以使用快速的指针碰撞技术.

2.Parallel收集器
并行标记压缩算法,与serial相似,吞吐量优先

3.mostly-concurrent收集器 CMS算法
低延迟优先
并发标记清除收集器
开始一个短的停顿,称为初始标记,它标记那些可以从外部直接可达的老年代对象,然后在并发标记阶段,它标记所有从这些对象可达的存活对象.
因为在标记期间,应用可能正在运行并更新更新饮用,需要再次停顿,称为重新标记,重新遍历所有在并发标记期间有变化的对象并进行最后的标记.

CMS收集器引入并发预清除阶段.
缺点:
标记清除算法会导致空闲内存空间不连续,需要额外的的数据结构纪录哪些空间空闲.
需要更大的java堆,因为清除前没有执行内存回收.

缺乏压缩导致空间碎片化

G1收集器

JIT编译器

JVM性能监控
-XX:+ScanvengeBeforeFullGC ,fullGc前先执行MinorGC
-XX:+PrintGCDetals

visual VM

