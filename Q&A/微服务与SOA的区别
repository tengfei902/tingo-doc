微服务强调的重点是业务系统需要彻底的组件化和服务化,原有的单个业务系统会拆分成为多个独立开发设计运行和运维的小应用.这些小应用通过服务完成
交互和集成.每个小应用除了完成自身的业务功能外,重点还要消费外部应用暴露的接口,同时将自身的能力朝外发布为服务.
SOA与微服务的区别:微服务不再强调传统SOA架构里比较重的ESB企业服务总线,同时SOA的思想进入到单个业务系统内部实现真正的组件化.

首先对于应用本身暴露出来的服务,是和应用一起部署的,即服务本身并不单独部署,服务本身就是业务组件已有的接口能力发布和暴露出来.
其次微服务本身ji架构来源于互联网思路,因此组件对外发布服务强调采用http rest api的方式进行.粗粒度服务
微服务思想考虑围绕业务领域组件来创建应用.
Devops开发测试和部署运维的一体化.
单个组件的持续集成,包括配置环境集成,自动打包部署,自动化的冒烟测试.对于微服务首先是单个组件本身的持续集成.
统一的服务管控和服务治理平台:管理组件本身暴露的服务的调用情况,服务本身的安全,日志和流量的管控.

1.微服务架构的优势和不足

API Gateway，这实际上微服务架构里面的很重要的内容，其作用类似于传统企业内部的ESB服务总线，
只是更加轻量和高性能来解决微服务的管控和治理问题。而对于负载均衡，缓存，路由，访问控制，服务代理，监控，日志等都属于基本的服务管控内容，
也是API Gateway需要考虑的核心能力
a.CAP原则 由于引入了分布式,较难解决事务一致性问题
b.集成复杂
c.部署问题 多服务节点部署,还包括部署后的配置,扩展和监控问题

2.使用API网关构建微服务
对于API服务网关即使微服务架构里面的轻量服务总线，解决服务管控和治理相关问题.
API 网关是一个服务器，也可以说是进入系统的唯一节点。这与面向对象设计模式中的 Facade 模式很像。API 网关封装内部系统的架构，并且提供
API 给各个客户端。它还可能还具备授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等功能。
API网关与ESB的区别在于API网关更加轻量和高性能,不需要考虑遗留系统的协议适配,也不需要考虑服务集成过程中大量数据的转换和映射.同时为了提升
性能,一般API网关不会记录日志.
API网关封装了程序的内部结构.
在我们期望的去中心化和全分布式架构中,网关又成为一个中心点或瓶颈点,正是由于这个原因在网关设计的时候必须考虑即使api网关宕机也不要影响
服务的调用和运行

api网关的设计和实现
API网关的性能和可扩展性很重要,因此API网关构建在一个支持异步,IO非阻塞的平台上.
对于网关需要实现底层多个细粒度的API组合的场景,推荐使用响应式编程模型而不是异步回调方式组合代码.原因主要是采用回调方式导致代码混乱,
另外API组合本身可能存在并行或先后调用.
进程间通信机制:异步消息机制,同步调用机制

3.微服务架构中的进程间通信(IPC)
EDA事件驱动架构本质是消息中间件和消息的发布订阅.
异步消息机制可以做到最大化的解耦，对于数据CUD的场景可以看到是比较容易通过异步消息机制实现的，但是会进一步引入事务一致性问题，即在采用异步消息
机制后往往通过BASE事务最终一致性来解决事务层面的问题。而对于查询功能可以看到是比较难通过异步消息API实现的，在引入这个之前可以看到需要考虑
两方面的问题并解决。

其一是服务网关需要有数据缓存能力，以解决无法从源端获取数据的场景。其二是前端开发框架本身需要支持异步调用和数据装载模式，特别是对于数据查询功能对于
用户来讲，在前端的感受仍然需要时同步的。即通过异步方式返回了查询数据后可以动态刷新前端展示界面。

服务版本的问题：这是不可避免要遇到的问题，特别是对于RestAPI调用，由于Json格式本身无Schema返回更加容易忽视了对服务 版本的管理和控制。要知道对
于Json数据格式变化仍然会导致RestAPI调用后处理失败。因此服务版本仍然采用大小版本管理机制比较好，对于小版本变 更则直接对原有服务进行覆盖同时对所
有受影响的服务消费端进行升级；而对于大版本升级则本质是新增加了一个新服务，而对于旧版本服务逐步迁移和替代。

处理局部失败：文中提到了Netfilix的服务解决方案，对于失败问题的解决要注意常用的仍然是服务超时设置，断路器机制，流量控制，缓存数据或默认值返回等。
不论采用哪种失败处理策略，都需要考虑应该尽量减少服务调用失败或超时对最终用户造成的影响。

使用同步的、基于请求/响应的 IPC 机制的时候，客户端向服务端发送请求，服务端处理请求并返回响应。一些客户端会由于等待服务端响应而被阻塞，而另外一些
客户端可能使用异步的、基于事件驱动的客户端代码，这些代码可能通过 Future 或者 Rx Observable 封装。然而，与使用消息机制不同，客户端需要响应及时
返回。这个模式中有很多可选的协议，但最常见的两个协议是 REST 和 Thrift。

Thrift 也能够让你选择传输协议，包括原始 TCP 和 HTTP。原始 TCP 比 HTTP 更高效，然而 HTTP 对于防火墙、浏览器和使用者来说更友好.可以看到当前
互联网OpenAPI平台和微服务架构实现中仍然是大量以采用Rest API接口为主。

而对于消息格式的选择，可以看到在使用RestAPI接口的时候，更多的是采用了Json消息格式而非XML，对于SOAP WebService则更多采用了XML消息格式。如果采
用Thrift则还可以采用二进制消息格式以提升性能。

4.服务发现的可行方案以及实现案例
结合云端PaaS和Docker后,服务ip是动态变化的
两种服务发现模式，即客户端发现模式和服务端发现模式:

客户端发现模式:

使用客户端发现模式时，客户端决定相应服务实例的网络位置，并且对请求实现负载均衡。客户端查询服务注册表，后者是一个可用服务实例的数据库；然后使用负
载均衡算法从中选择一个实例，并发出请求。客户端从服务注册服务中查询，其中是所有可用服务实例的库。客户端使用负载均衡算法从多个服务实例中选择出一 个，
然后发出请求,dubbo使用此种方式

在这种模式的实现中有两个重点，其一是动态负载均衡算法，其二是服务网关需要能够对原始服务提供点进行实时的心跳检测以确定服务提供的可用性。

Netflix OSS 是客户端发现模式的绝佳范例。Netflix Eureka 是一个服务注册表，为服务实例注册管理和查询可用实例提供了 REST API 接口。Netflix Ribbon 是
IPC 客户端，与 Eureka 一起实现对请求的负载均衡。

缺点：底层的IP虽然动态提供出去了，但是最终仍然暴露给了服务消费方，再需要进一步做安全和防火墙隔离的场景下显然是不能满足要求的。


服务端发现模式:

客户端通过负载均衡器向某个服务提出请求，负载均衡器查询服务注册表，并将请求转发到可用的服务实例。如同客户端发现，服务实例在服务注册表中注册或注销。
在原文中有图示，基本看图就清楚了，即在服务注册库前新增加了一个Load Balancer节点。注：这两个节点感觉是可以合并到API GateWay的能力中去的。

服务端发现模式兼具优缺点。它最大的优点是客户端无需关注发现的细节，只需要简单地向负载均衡器发送请求，这减少了编程语言框架需要完成的发现逻辑。并且
如上文所述，某些部署环境免费提供这一功能。这种模式也有缺点。除非负载均衡器由部署环境提供，否则会成为一个需要配置和管理的高可用系统组件。

服务实例必须在注册表中注册和注销。注册和注销有两种不同的方法。方法一是服务实例自己注册，也叫自注册模式（self-registration pattern）；另一种是采
用管理服务实例注册的其它系统组件，即第三方注册模式

在这种模式的实现中有两个重点，其一是动态负载均衡算法，其二是服务网关需要能够对原始服务提供点进行实时的心跳检测以确定服务提供的可用性。

